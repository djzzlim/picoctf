# [heap 0](https://play.picoctf.org/practice/challenge/438)

## Challenge Information

- **Category**: Binary Exploitation
- **Difficulty**: Easy
- **Description**: Are overflows just a stack concern?

## Solution Overview

This challenge involves exploiting a **heap overflow vulnerability** in a C program. By writing more data than a buffer can hold, we can overwrite adjacent memory on the heap, including a critical variable that controls access to the flag. This demonstrates that buffer overflows aren't limited to stack-based memory.

## Hints

- What part of the heap do you have control over and how far is it from the safe_var?

## Detailed Walkthrough

### Step 1: Understanding the Challenge

When we run the program, it presents us with a menu:

```
Welcome to heap0!
I put my data on the heap so it should be safe from any tampering.
Since my data isn't on the stack I'll even let you write whatever info you want to the heap, I already took care of using malloc for you.
Heap State:
+-------------+----------------+
[*] Address   ->   Heap Data   
+-------------+----------------+
[*]   0x5613564766b0  ->   pico
+-------------+----------------+
[*]   0x5613564766d0  ->   bico
+-------------+----------------+
1. Print Heap:          (print the current state of the heap)
2. Write to buffer:     (write to your own personal block of data on the heap)
3. Print safe_var:      (I'll even let you look at my variable on the heap, I'm confident it can't be modified)
4. Print Flag:          (Try to print the flag, good luck)
5. Exit
```

The program shows us two heap allocations with their addresses and contents. The first contains "pico" and the second contains "bico".

### Step 2: Identifying the Vulnerability

The program allows us to:
1. View the current state of the heap
2. Write data to a buffer on the heap
3. View a "safe_var" value (which likely controls access to the flag)
4. Attempt to print the flag

The vulnerability lies in option 2: the program doesn't properly limit how much data we can write to the buffer, allowing us to overflow into adjacent memory areas.

### Step 3: Calculating the Overflow Size

Looking at the addresses of the two heap allocations:
- First buffer starts at: `0x5613564766b0`
- Second buffer starts at: `0x5613564766d0`

The difference between these addresses is `0xd0 - 0xb0 = 0x20`, which equals 32 in decimal. This means we need exactly 32 characters to fill the first buffer completely before we can start overwriting the second buffer.

### Step 4: Crafting the Exploit

To exploit this vulnerability, we need to:
1. Write exactly 32 'a' characters to fill the first buffer
2. Add "pico" to overwrite the beginning of the second buffer (changing "bico" to "pico")

Our payload:
```
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa + pico
```

The 32 'a's completely fill the allocated space for the first buffer, and then "pico" overwrites the start of the second buffer.

### Step 5: Executing the Exploit

Here's the step-by-step solution:

1. Select option 2 to write to the buffer
2. Enter: `aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaapico`
3. Select option 1 to check the heap state and confirm our overflow worked:

```
Heap State:
+-------------+----------------+
[*] Address   ->   Heap Data   
+-------------+----------------+
[*]   0x5613564766b0  ->   aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaapico
+-------------+----------------+
[*]   0x5613564766d0  ->   pico
+-------------+----------------+
```

We can see that our input successfully overwrote the second allocation, changing "bico" to "pico".

4. Select option 4 to print the flag
5. Receive the "YOU WIN" message, confirming our exploit worked

### Step 6: Retrieving the Flag

After successfully exploiting the heap overflow vulnerability and triggering the win condition, the program displays "YOU WIN" and provides the flag.

```
YOU WIN
picoCTF{my_first_heap_overflow_1ad0e1a6}
```

## Tools and Resources Used

- **Terminal**: For interacting with the challenge program
- **Hexadecimal arithmetic**: For calculating the exact buffer size needed (0xd0 - 0xb0 = 0x20 = 32)

## Flag

```
picoCTF{my_first_heap_overflow_1ad0e1a6}
```

## Learning Points

- **Heap Overflow**: Buffer overflows aren't just stack-based vulnerabilities - they can occur in heap-allocated memory too
- **Memory Layout**: Understanding how adjacent allocations in memory can affect each other
- **Address Calculation**: Using address differences to determine exact overflow sizes
- **Input Validation**: The importance of validating and limiting user input, regardless of where it's stored
- **Heap Management**: How memory is allocated and managed on the heap

## Mitigation Strategies

To prevent such vulnerabilities in real-world applications:

- **Implement bounds checking** on all user-controlled inputs
- **Utilize heap protection mechanisms** available in modern compilers
- **Separate user input buffers** from control variables in memory

## References

- [Heap Exploitation Basics](https://heap-exploitation.dhavalkapil.com/)
- [Common Weakness Enumeration: CWE-122 (Heap-based Buffer Overflow)](https://cwe.mitre.org/data/definitions/122.html)